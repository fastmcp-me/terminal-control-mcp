Metadata-Version: 2.4
Name: interactive-automation-mcp
Version: 1.0.0
Summary: Interactive Automation MCP Server for Claude Code
Author-email: Your Name <your.email@example.com>
License: MIT
Project-URL: Homepage, https://github.com/yourusername/interactive-automation-mcp
Project-URL: Documentation, https://github.com/yourusername/interactive-automation-mcp/blob/main/README.md
Project-URL: Repository, https://github.com/yourusername/interactive-automation-mcp
Project-URL: Issues, https://github.com/yourusername/interactive-automation-mcp/issues
Keywords: mcp,automation,interactive,claude,debugging,ssh,database
Classifier: Development Status :: 4 - Beta
Classifier: Intended Audience :: Developers
Classifier: License :: OSI Approved :: MIT License
Classifier: Programming Language :: Python :: 3
Classifier: Programming Language :: Python :: 3.10
Classifier: Programming Language :: Python :: 3.11
Classifier: Programming Language :: Python :: 3.12
Classifier: Topic :: Software Development :: Libraries :: Python Modules
Classifier: Topic :: System :: Systems Administration
Classifier: Topic :: Software Development :: Debuggers
Requires-Python: >=3.10
Description-Content-Type: text/markdown
Requires-Dist: mcp>=1.0.0
Requires-Dist: pexpect>=4.8.0
Requires-Dist: typing-extensions>=4.0.0
Requires-Dist: pydantic>=2.11.7
Provides-Extra: dev
Requires-Dist: mcp[cli]>=1.0.0; extra == "dev"
Requires-Dist: black>=22.0.0; extra == "dev"
Requires-Dist: isort>=5.10.0; extra == "dev"
Requires-Dist: mypy>=0.950; extra == "dev"
Requires-Dist: ruff>=0.1.0; extra == "dev"
Requires-Dist: types-pexpect>=4.8.0; extra == "dev"

# Interactive Automation MCP Server

A modern FastMCP-based server that enables Claude Code to control ANY terminal programs through agent-directed automation. Built with the latest MCP Python SDK 1.12.0, this server provides intelligent terminal session management for all types of commands - from simple utilities like `ls` and `git status` to complex interactive programs like SSH sessions, database connections, interactive installers, and debugging workflows.

## ✨ Features

### 🏗️ **Modern FastMCP Architecture**
- **⚡ FastMCP Framework**: Built with MCP Python SDK 1.12.0 for optimal performance
- **🔧 Decorator-Based Tools**: Clean `@mcp.tool()` decorators with automatic schema generation
- **📝 Pydantic Models**: Type-safe input/output validation with structured data support
- **🎯 Automatic Schema Generation**: JSON schemas generated from Python type hints
- **🔄 Lifespan Management**: Proper startup/shutdown with resource cleanup

### 🚀 **Agent-Controlled Terminal Automation**
- **🎯 Agent-Controlled Interaction**: Agents have full control over timing and interaction flow
- **📊 Session Management**: Maintain persistent sessions with automatic cleanup
- **🔍 Real-time Screen Content**: Get current terminal output with timestamps
- **🛡️ Simplified Design**: No complex automation patterns - agents decide when to act
- **🐛 Universal Terminal Support**: Control ANY terminal program (interactive and non-interactive)
- **🔒 User-Controlled Security**: Maximum flexibility with user responsibility

### 💪 **Performance & Reliability**
- **📦 Minimal Dependencies**: Only essential dependencies for terminal interaction
- **⚡ Fast Installation**: Lightweight package with minimal footprint
- **🛡️ Type Safety**: Full type coverage with mypy and Pydantic validation
- **🧹 Clean Code**: Modern Python with black formatting and ruff linting
- **⏱️ Smart Timeouts**: Process startup timeouts only - agents control interaction timing

## 🚀 Quick Start

### Installation

```bash
# Create virtual environment
uv venv
source .venv/bin/activate

# Install the package
pip install .

# Or install in development mode
pip install -e ".[dev]"
```

### Configuration

Once installed, configure the MCP server in your AI assistant:

## 🎯 Platform Setup

### 🤖 Claude Code (Anthropic)

1. **Install the package first (required for console script)**:
   ```bash
   # Install the package to create the console script
   pip install .
   ```

2. **Add the MCP server using Claude Code CLI**:
   ```bash
   # Recommended: User scope (available across all projects)
   claude mcp add interactive-automation -s user interactive-automation-mcp

   # Alternative: Local scope (default - current project only)
   claude mcp add interactive-automation interactive-automation-mcp

   # Alternative: Project scope (shared via .mcp.json in version control)
   claude mcp add interactive-automation -s project interactive-automation-mcp
   ```

3. **Verify the server was added**:
   ```bash
   claude mcp list
   ```

**Note**: The MCP server will be automatically launched by Claude Code when needed - no manual activation required.

### 🔧 Visual Studio Code with GitHub Copilot

1. **Configure in VS Code settings** (MCP extension or built-in support):
   - Open **Settings** (`Ctrl+,` or `Cmd+,`)
   - Search for "MCP" or "Model Context Protocol"
   - Add server configuration:
   ```json
   {
     "mcp.servers": {
       "interactive-automation": {
         "command": "/path/to/interactive-automation-mcp/.venv/bin/python",
         "args": ["-m", "interactive_automation_mcp.main"],
         "cwd": "/path/to/interactive-automation-mcp"
       }
     }
   }
   ```

2. **Alternative configuration using console script**:
   ```json
   {
     "mcp.servers": {
       "interactive-automation": {
         "command": "/path/to/interactive-automation-mcp/.venv/bin/interactive-automation-mcp",
         "cwd": "/path/to/interactive-automation-mcp"
       }
     }
   }
   ```

3. **Reload VS Code** to apply the configuration

## 🛠️ Complete Tool Set (5 Agent-Controlled Tools)

### 📋 Session Management (2 tools)

#### **`list_sessions`**
List all active terminal sessions with detailed status information.

Shows comprehensive session information:
- Session IDs and commands for identification
- Session states (active, waiting, error, terminated)
- Creation timestamps and last activity times
- Total session count (max 50 concurrent)

#### **`destroy_session`**
Terminate and cleanup a terminal session safely.

### 🤖 Agent-Controlled Interaction (2 tools)

#### **`get_screen_content`**
Get current terminal screen content with timestamp.

**Key features:**
- Returns current terminal output visible to user
- Includes ISO timestamp for agent timing decisions
- Process running status
- Agents decide when to wait longer based on timestamps

**Agent workflow:**
1. Call `get_screen_content` to see current terminal state
2. Analyze screen content and timestamp
3. Decide whether to wait longer or take action
4. Use `send_input` when process is ready for input

#### **`send_input`**
Send text input to a terminal session.

**Features:**
- Send any text input to the running process
- Automatic newline appending
- No timeouts - agents control timing
- Works with any terminal program

### 🔗 Session Creation (1 tool)

#### **`execute_command`**
Execute any command and create a terminal session.

**Universal command execution:**
- ANY command: `ssh host`, `python script.py`, `ls`, `docker run -it image`, `make install`
- ALL commands create persistent sessions (interactive and non-interactive)
- Process startup timeout only (default: 30 seconds)
- Environment variables and working directory control
- NO output returned - agents must use `get_screen_content` to see terminal state
- Returns session ID for agent-controlled interaction

**Agent-controlled workflow for ALL commands:**
1. `execute_command` - Creates session and starts process
2. `get_screen_content` - Agent sees current terminal state (output or interface) with timestamp
3. `send_input` - Agent sends input if process is waiting for interaction
4. Repeat steps 2-3 as needed (agent controls timing)
5. `destroy_session` - Clean up when finished (REQUIRED for all sessions)

## 📚 Usage Examples & Tutorial

### Prerequisites

- Python 3.10+ installed
- Claude Code CLI installed and configured
- Basic familiarity with command line tools

### Quick Start Commands

```bash
# Install and activate
pip install -e ".[dev]"
claude mcp add interactive-automation -s user interactive-automation-mcp

# Verify installation
claude mcp list

# Test basic functionality
python tests/test_simplified_workflow.py
```

### Essential Tool Examples

#### Session Management
```bash
# Ask Claude Code:
"Use execute_command to start 'python3 -u' and show me the session"
"Use list_sessions to show all active sessions"
"Use get_screen_content to see what's on screen right now"
"Use send_input to send 'print(2+2)' to the Python session"
"Use destroy_session to terminate session [session_id]"
```

#### Interactive Terminal Control
```bash
# Ask Claude Code:
"Start a Python REPL and calculate 2+2 step by step"
"Connect to SSH and check disk usage interactively" 
"Start mysql client and show tables when ready"
"Launch a debugger and set breakpoints interactively"
"Run 'ls -la' and show me the output"
"Execute 'git status' and tell me what files are modified"
```

#### Agent-Controlled Workflows
```bash
# Ask Claude Code:
"Start python debugger, wait for prompt, set breakpoint at line 10, then continue"
"Connect to SSH, wait for login, enter password when prompted, then run 'ls'"
"Start interactive installer, respond to prompts as they appear"
```

### Advanced Usage Examples

#### Multi-Step Interactive Sessions

**Python Debugging**:
> "Start a Python debugger session, wait for the (Pdb) prompt, set a breakpoint, then continue execution and examine variables when we hit it."

**SSH Session Management**:
> "Connect to SSH server, wait for password prompt, authenticate, then navigate to log directory and monitor the latest log file."

**Database Interaction**:
> "Start mysql client, wait for connection, authenticate when prompted, then show databases and describe table structure."

### Real-World Applications

**Development Workflows**:
- Interactive debugging with GDB, PDB, LLDB
- Git operations requiring user input
- Docker container interaction
- Kubernetes pod debugging

**System Administration**:
- SSH server management
- Database administration
- Interactive installers and configurators
- System monitoring and diagnostics

**Testing and QA**:
- Interactive test runners
- Manual testing of CLI tools
- Integration testing across systems

### Troubleshooting

#### Common Issues

**Session Won't Start**:
- Verify the command exists and is executable
- Check file permissions and paths
- Ensure working directory is correct

**Process Not Responding**:
- Use `get_screen_content` to see current state
- Check timestamps to see if output is recent
- Look for blocking prompts requiring input

**Session Becomes Unresponsive**:
- Use `list_sessions` to check session state
- Use `destroy_session` to clean up and start fresh
- Check for programs waiting for input

#### Debug Mode

Enable verbose logging:
```bash
export INTERACTIVE_AUTOMATION_LOG_LEVEL=DEBUG
claude code
```

### Development Testing

```bash
# Run functionality tests
python tests/test_simplified_workflow.py
python tests/test_execute_command.py

# Install with development dependencies
pip install -e ".[dev]"

# Run code quality checks
ruff check src/ tests/
mypy src/ --ignore-missing-imports

# Run all tests
pytest tests/
```

## 💡 Universal Examples

### 🔑 Agent-Controlled Interactive Examples
```bash
# Natural language commands to Claude:
"Start SSH session to prod.example.com, wait for prompts, handle authentication"
"Launch Python debugger, set breakpoints when ready, step through execution"
"Start mysql client, authenticate when prompted, then run diagnostic queries"
"Connect to docker container interactively, explore filesystem step by step"
"Launch Redis CLI, wait for connection, then check memory usage"
```

### 🚀 Terminal Program Examples
```bash
# Primary use cases - Interactive and long-running commands:
"Start session: ssh user@host"
"Launch: docker exec -it myapp bash"
"Run: kubectl exec -it pod-name -- sh"
"Debug: gdb ./myprogram"
"Profile: python -m pdb myscript.py"
"Monitor: tail -f /var/log/syslog"
"Stream: nc -l 8080"
"Connect: minicom /dev/ttyUSB0"
"Attach: tmux attach-session -t main"

# Also works with simple commands (though direct execution may be more efficient):
"Execute: ls -la /var/log"
"Run: git status"
"Check: ps aux | grep python"
```

### 🐍 Agent-Controlled Debugging
```bash
# Natural language commands to Claude:
"Start PDB debugging session, wait for prompt, then set strategic breakpoints"
"Launch debugger, examine crash point, analyze variables step by step"
"Debug Flask app interactively: set breakpoints, trace requests, inspect state"
"Attach to running process, debug live issues with agent timing control"
```

### 🔧 Complex Agent Workflows
```bash
# Natural language commands to Claude:
"SSH to server, authenticate, check services, restart if needed - handle all prompts"
"Debug crashed program: load core dump, analyze stack, suggest fixes interactively"
"Database maintenance: connect, check health, run maintenance, monitor progress"
"Deploy application: upload, configure, test, rollback if issues - handle all interactions"
```

## 🔒 Security

**Agent-Controlled Design Philosophy**: Maximum flexibility with user responsibility
- **No command filtering** - All commands allowed (agents control what runs)
- **No path restrictions** - All paths accessible (user controls access)  
- **All commands create sessions** - Both interactive and non-interactive commands create persistent sessions
- **Agent-controlled output** - No direct output from execute_command, agents use get_screen_content
- **Rate limiting** - 60 calls per minute to prevent abuse
- **Session limits** - 50 concurrent sessions to prevent resource exhaustion
- **Comprehensive logging** - Full audit trail of all operations
- **User responsibility** - Security is managed by the user and agent, not the MCP server

## 📁 Project Structure

```
interactive-automation-mcp/
├── pyproject.toml              # Modern Python project configuration
├── README.md                   # This comprehensive guide
├── CLAUDE.md                   # Development and technical documentation
├── src/
│   └── interactive_automation_mcp/
│       ├── __init__.py        # Package initialization
│       ├── main.py            # Main MCP server entry point (FastMCP)
│       ├── session_manager.py # Session lifecycle management
│       ├── interactive_session.py # Terminal session handling
│       ├── security.py        # Security controls and validation
│       ├── models.py          # Pydantic models for type safety
│       ├── interaction_logger.py # Comprehensive logging
│       └── utils.py           # Utility functions
├── tests/                      # Comprehensive test suite
│   ├── test_simplified_workflow.py # Main functionality tests
│   ├── test_execute_command.py     # Command execution tests
│   └── test_new_workflow.py        # Workflow validation tests
└── docs/                       # Documentation
```

## 🚀 Development Status

- ✅ **Production Ready** - All 5 agent-controlled tools implemented and tested
- ✅ **FastMCP Architecture** - Modern MCP Python SDK 1.12.0 implementation
- ✅ **Agent-Controlled Design** - Simplified architecture with agent timing control
- ✅ **Type Safety** - Full Pydantic model validation and mypy type coverage
- ✅ **Minimal Dependencies** - Only essential dependencies for terminal interaction
- ✅ **Comprehensive Security** - Security controls with user/agent responsibility
- ✅ **Clean Architecture** - Well-organized, maintainable code with modern tooling
- ✅ **Universal Terminal Support** - Works with ANY terminal program
- ✅ **Code Quality** - All linting (ruff) and type checking (mypy) passes

## 🔄 Architecture Changes

**Major Simplification (2025)**: Transitioned from complex automation patterns to agent-controlled interaction:
- **Removed**: Complex expect/respond automation engine
- **Added**: Agent timing control with timestamped screen content
- **Simplified**: Only process startup timeouts - agents control interaction timing
- **Enhanced**: Real-time screen content access with timestamps
- **Result**: Cleaner, more reliable, agent-directed terminal automation

## 📄 License

MIT License - see LICENSE file for details

## 🤝 Contributing

1. Fork the repository
2. Create a feature branch (`git checkout -b feature/amazing-feature`)
3. Make your changes
4. Add tests for new functionality
5. Ensure all tests pass: `ruff check src/ tests/ && mypy src/ --ignore-missing-imports`
6. Commit your changes (`git commit -m 'Add amazing feature'`)
7. Push to the branch (`git push origin feature/amazing-feature`)
8. Open a Pull Request

## 🙏 Acknowledgments

- Built on the [Model Context Protocol (MCP)](https://github.com/anthropics/mcp) by Anthropic
- Uses [pexpect](https://pexpect.readthedocs.io/) for terminal automation
