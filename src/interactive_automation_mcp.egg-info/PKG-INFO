Metadata-Version: 2.4
Name: interactive-automation-mcp
Version: 1.0.0
Summary: Interactive Automation MCP Server for Claude Code
Author-email: Your Name <your.email@example.com>
License: MIT
Project-URL: Homepage, https://github.com/yourusername/interactive-automation-mcp
Project-URL: Documentation, https://github.com/yourusername/interactive-automation-mcp/blob/main/README.md
Project-URL: Repository, https://github.com/yourusername/interactive-automation-mcp
Project-URL: Issues, https://github.com/yourusername/interactive-automation-mcp/issues
Keywords: mcp,automation,interactive,claude,debugging,ssh,database
Classifier: Development Status :: 4 - Beta
Classifier: Intended Audience :: Developers
Classifier: License :: OSI Approved :: MIT License
Classifier: Programming Language :: Python :: 3
Classifier: Programming Language :: Python :: 3.10
Classifier: Programming Language :: Python :: 3.11
Classifier: Programming Language :: Python :: 3.12
Classifier: Topic :: Software Development :: Libraries :: Python Modules
Classifier: Topic :: System :: Systems Administration
Classifier: Topic :: Software Development :: Debuggers
Requires-Python: >=3.10
Description-Content-Type: text/markdown
Requires-Dist: mcp>=1.0.0
Requires-Dist: pexpect>=4.8.0
Requires-Dist: ptyprocess>=0.7.0
Requires-Dist: typing-extensions>=4.0.0
Requires-Dist: pydantic>=2.11.7
Provides-Extra: dev
Requires-Dist: mcp[cli]>=1.0.0; extra == "dev"
Requires-Dist: pytest>=7.0.0; extra == "dev"
Requires-Dist: pytest-asyncio>=0.21.0; extra == "dev"
Requires-Dist: black>=22.0.0; extra == "dev"
Requires-Dist: isort>=5.10.0; extra == "dev"
Requires-Dist: mypy>=0.950; extra == "dev"
Requires-Dist: ruff>=0.1.0; extra == "dev"
Requires-Dist: types-pexpect>=4.8.0; extra == "dev"

# Interactive Automation MCP Server

A modern FastMCP-based server that enables Claude Code to perform expect/pexpect-style automation for interactive programs. Built with the latest MCP Python SDK 1.12.0, this server provides intelligent automation for programs that require user interaction, such as SSH sessions, database connections, interactive installers, and debugging workflows.

## ✨ Features

### 🏗️ **Modern FastMCP Architecture**
- **⚡ FastMCP Framework**: Built with MCP Python SDK 1.12.0 for optimal performance
- **🔧 Decorator-Based Tools**: Clean `@mcp.tool()` decorators with automatic schema generation
- **📝 Pydantic Models**: Type-safe input/output validation with structured data support
- **🎯 Automatic Schema Generation**: JSON schemas generated from Python type hints
- **🔄 Lifespan Management**: Proper startup/shutdown with resource cleanup

### 🚀 **Enhanced Automation Features**
- **🔄 Automated Interactive Sessions**: Handle complex multi-step interactions with terminal programs
- **🎯 Smart Pattern Matching**: Enhanced regex support with case-insensitive options
- **📊 Advanced Session Management**: Maintain persistent sessions with automatic cleanup
- **🛡️ Error Recovery**: Consecutive failure tracking and automatic retry logic
- **🔍 Detailed Debugging**: Comprehensive error reporting with helpful suggestions
- **🐛 Universal Debugging**: Debug ANY program (GDB, PDB, LLDB, custom debuggers)
- **🚀 Universal Command Execution**: Run ANY terminal command with optional automation
- **🔒 User-Controlled Security**: Maximum flexibility with user responsibility

### 💪 **Performance & Reliability**
- **📦 Minimal Dependencies**: Only 4 essential dependencies (reduced from 9)
- **⚡ Fast Installation**: Lightweight package with minimal footprint
- **🛡️ Type Safety**: Full type coverage with mypy and Pydantic validation
- **🧹 Clean Code**: Modern Python with black formatting and ruff linting
- **⏱️ Smart Timeouts**: Enhanced timeout handling with automatic recovery

## 🚀 Quick Start

### Installation

```bash
# Create virtual environment
uv venv
source .venv/bin/activate

# Install the package
pip install .

# Or install in development mode
pip install -e ".[dev]"
```

### Configuration

Once installed, configure the MCP server in your AI assistant:

## 🎯 Platform Setup

### 🤖 Claude Code (Anthropic)

1. **Install the package first (required for console script)**:
   ```bash
   # Install the package to create the console script
   pip install .
   ```

2. **Add the MCP server using Claude Code CLI**:
   ```bash
   # Recommended: User scope (available across all projects)
   claude mcp add interactive-automation -s user interactive-automation-mcp

   # Alternative: Local scope (default - current project only)
   claude mcp add interactive-automation interactive-automation-mcp

   # Alternative: Project scope (shared via .mcp.json in version control)
   claude mcp add interactive-automation -s project interactive-automation-mcp
   ```

3. **Verify the server was added**:
   ```bash
   claude mcp list
   ```

**Note**: The MCP server will be automatically launched by Claude Code when needed - no manual activation required.

### 🔧 Visual Studio Code with GitHub Copilot

1. **Configure in VS Code settings** (MCP extension or built-in support):
   - Open **Settings** (`Ctrl+,` or `Cmd+,`)
   - Search for "MCP" or "Model Context Protocol"
   - Add server configuration:
   ```json
   {
     "mcp.servers": {
       "interactive-automation": {
         "command": "/path/to/interactive-automation-mcp/.venv/bin/python",
         "args": ["-m", "interactive_automation_mcp.main"],
         "cwd": "/path/to/interactive-automation-mcp"
       }
     }
   }
   ```

2. **Alternative configuration using console script**:
   ```json
   {
     "mcp.servers": {
       "interactive-automation": {
         "command": "/path/to/interactive-automation-mcp/.venv/bin/interactive-automation-mcp",
         "cwd": "/path/to/interactive-automation-mcp"
       }
     }
   }
   ```

3. **Reload VS Code** to apply the configuration

## 🛠️ Complete Tool Set (6 Enhanced Universal Tools)

### 📋 Session Management (3 tools)

#### **`create_interactive_session`**
Universal tool for starting ANY interactive program that requires user input.

**Examples:**
- Debuggers: `python -u -m pdb script.py`, `gdb ./program`, `node inspect app.js`
- Remote access: `ssh user@host`, `telnet server`, `kubectl exec -it pod -- bash`
- Databases: `mysql -u root -p`, `psql -h host -U user db`, `redis-cli`
- Development: `npm run dev`, `docker exec -it container bash`, `make test`
- System tools: `top`, `htop`, `vim file.txt`, any interactive CLI tool

Returns a session_id for use with expect_and_respond and multi_step_automation.
Sessions auto-cleanup after timeout (default: 1 hour, max: 24 hours).

#### **`list_sessions`**
List all active interactive sessions with detailed status information.

Shows comprehensive session information:
- Session IDs and commands for identification
- Session states (active, waiting, error, terminated)
- Creation timestamps and last activity times
- Resource usage and timeout information

#### **`destroy_session`**
Terminate and cleanup an interactive session safely.

### 🤖 Enhanced Automation (2 tools)

#### **`expect_and_respond`**
Universal single-step automation for ANY interactive program.

**Pattern matching features:**
- Supports regex patterns (e.g., `\(Pdb\)`, `Password.*:`, `Continue\?.*`)
- Case-sensitive or case-insensitive matching
- Automatic timeout handling with helpful error messages
- Enhanced error recovery and debugging information

**Common use cases:**
- Debugger: expect `\(Pdb\)` respond `n` (step to next line)
- SSH login: expect `Password:` respond `secretpass`
- Database: expect `mysql>` respond `SHOW DATABASES;`
- Installer: expect `Continue\? \[y/N\]` respond `y`

#### **`multi_step_automation`**
Universal multi-step automation engine for orchestrating complex interactive workflows.

**Advanced features:**
- Automatic error recovery with consecutive failure tracking
- Optional steps for conditional workflows
- Case-sensitive/insensitive pattern matching per step
- Detailed completion statistics and failure analysis
- Smart timeout handling with helpful suggestions

**Real-world examples:**
- SSH workflow: login → navigate → execute commands → collect results
- Database admin: connect → authenticate → run queries → backup
- Debugging session: set breakpoints → step through → inspect variables
- System deployment: connect → upload → configure → restart services

**Configuration options:**
- `optional: true` - Skip failed steps without stopping workflow
- `stop_on_failure: false` - Continue workflow even when steps fail
- `case_sensitive: true` - Exact pattern matching (default: false)
- `timeout: 60` - Custom timeout per step (default: 30 seconds)

### 🔗 Universal Command Execution (1 tool)

#### **`execute_command`**
Execute any command with optional automation patterns and follow-up commands.

The most convenient automation tool - combines session creation, automation, and cleanup.
Perfect for one-off commands and simple automation workflows.

**Universal command execution:**
- ANY command: `ssh host`, `python script.py`, `docker run -it image`, `make install`
- Automatic prompt handling with regex patterns
- Follow-up command chaining for post-execution tasks
- Environment variables and working directory control
- Built-in session lifecycle management (create → automate → cleanup)

**When to use:**
- Quick automation tasks with simple prompt handling
- One-off command execution with known prompts
- Scripts that need automated responses to continue

**When to use create_interactive_session instead:**
- Long-running debugging or interactive sessions
- Complex workflows requiring multiple tools
- Sessions you want to manage manually

## 📚 Complete Tutorial & Examples

### Prerequisites

- Python 3.10+ installed (updated requirement)
- Claude Code CLI installed and configured
- Basic familiarity with command line tools
- Understanding of debugging concepts

### Step-by-Step Debugging Tutorial

We'll use the provided `examples/example_debug.py` file to demonstrate all tools. This script contains intentional bugs perfect for debugging practice.

#### Example Script Analysis

The script includes:
- `factorial(n)`: Recursive factorial calculation
- `fibonacci(n)`: Recursive Fibonacci calculation  
- `divide_numbers(a, b)`: Division with potential zero division
- `buggy_function()`: Intentional index out of bounds error
- `main()`: Orchestrates all function calls

#### Tutorial Steps

Start Claude Code and ensure the MCP server is loaded:

```bash
claude code
```

#### Step 1: Create a Debugging Session

Ask Claude to create an interactive Python debugger session:

> "Use the create_interactive_session tool to start a Python debugger session for the file examples/example_debug.py. Set the session name to 'Python Debugger Session' and timeout to 1800 seconds."

Claude will execute:
- Command: `python -u -m pdb examples/example_debug.py`
- Working directory: current project directory
- This creates a Python debugger session and returns a session ID

#### Step 2: Verify Session Creation

Ask Claude to check active sessions:

> "Use the list_sessions tool to show me all active sessions."

This confirms your debugging session was created and shows its current state.

#### Step 3: Set Breakpoints with Multi-Step Automation

Ask Claude to set up the debugging environment:

> "Use the multi_step_automation tool on my debugging session to:
> 1. Set a breakpoint at the buggy_function
> 2. Set a breakpoint at divide_numbers  
> 3. List all breakpoints to verify
> Make sure to wait for the (Pdb) prompt between each step."

Claude will:
- Wait for the debugger prompt
- Execute `b buggy_function` to set first breakpoint
- Execute `b divide_numbers` to set second breakpoint  
- Execute `b` to list breakpoints

#### Step 4: Start Execution and Debug Division

Ask Claude to begin debugging:

> "Use the expect_and_respond tool to start execution with 'c' command, then when we hit the divide_numbers breakpoint (look for '-> return a / b'), print the values of variables a and b using 'p a, b'."

This demonstrates:
- Continuing execution until breakpoint
- Examining variable values at runtime
- Understanding the division by zero scenario

#### Step 5: Debug Through Exception Handling

Continue debugging the error handling:

> "Use multi_step_automation to:
> 1. Continue execution past this breakpoint
> 2. When we hit the zero division case again, examine the variables
> 3. Check the stack trace with 'bt'
> 4. Continue past the handled exception
> Set stop_on_failure to false since some steps might not match exactly."

This shows how the script properly handles the division by zero error.

#### Step 6: Debug the Index Error

Focus on the intentional bug:

> "Use expect_and_respond to continue until we reach the buggy_function breakpoint (look for '-> result += data[i]'), then print the values of i, len(data), and data to see the index error."

This reveals:
- The loop goes one iteration too far
- Index `i` equals `len(data)` causing the error
- How the bug manifests in practice

#### Step 7: Run Complete Script with Automation

Demonstrate the execute_command tool:

> "Use the execute_command tool to run the complete script (python examples/example_debug.py) with automation patterns that respond to the expected error messages:
> - When you see 'Error caught: division by zero', respond with an echo confirming it was handled
> - When you see 'Bug found: list index out of range', respond with an echo noting the error was detected
> Also add follow-up commands to log that the debugging session completed."

This demonstrates:
- Running scripts with automated responses to expected outputs
- Handling multiple error scenarios
- Adding follow-up actions after execution

#### Step 8: Clean Up

Finally, clean up the session:

> "Use the destroy_session tool to terminate my debugging session."

This properly closes the debugger and frees resources.

### Quick Start Commands

```bash
# Install and activate
pip install -e ".[dev]"
claude mcp add interactive-automation -s user interactive-automation-mcp

# Verify installation
claude mcp list

# Test basic functionality
python tests/test_basic.py
```

### Essential Tool Examples

#### Session Management
```bash
# Ask Claude Code:
"Use create_interactive_session tool with command 'echo hello world' and then use list_sessions tool"
"Use create_interactive_session tool: python3 -c 'import code; code.interact()' to calculate 2+2"
"Use destroy_session tool to terminate session [session_id]"
```

#### Basic Automation
```bash
# Ask Claude Code:
"Use expect_and_respond tool on session [session_id] to wait for 'Name:' pattern and respond 'Alice'"
"Use multi_step_automation tool with steps: wait for 'login:', respond 'user', then wait for 'password:', respond 'pass'"
```

#### Universal Command Execution
```bash
# Ask Claude Code:
"Use execute_command tool: 'top' with execution_timeout 5 seconds then destroy session"
"Use execute_command tool: 'ssh localhost' with automation patterns for password prompts"
"Use execute_command tool: 'docker exec -it mycontainer bash' with follow-up commands to list files"
```

### Advanced Usage Examples

#### Complex Debugging Scenarios

**Multiple Sessions**: Create separate sessions for different components:
> "Create one session for the main script and another for testing individual functions."

**Conditional Automation**: Handle optional steps:
> "Set up multi-step automation where some steps are marked as optional in case the program flow varies."

**Environment Setup**: Configure debugging environments:
> "Create a session with custom environment variables like PYTHONPATH and DEBUG_MODE set."

#### Real-World Applications

**Database Debugging**:
> "Create a session for mysql client and automate login prompts."

**SSH Session Management**:
> "Set up automated SSH connections with password or key prompts."

**Interactive Installers**:
> "Automate software installation prompts and configuration steps."

### Troubleshooting

#### Common Issues

**Session Won't Start**:
- Verify the command exists: `which python`
- Check file permissions: `ls -la examples/example_debug.py`
- Ensure working directory is correct

**Automation Patterns Don't Match**:
- Test patterns manually in the debugger first
- Check if output formatting differs from expected
- Increase timeout values for slow responses
- Try case-insensitive matching with `case_sensitive: false`

**Session Becomes Unresponsive**:
- Use list_sessions to check session state
- Use destroy_session to clean up and start fresh
- Check for blocking prompts requiring input

#### Debug Mode

Enable verbose logging:
```bash
export INTERACTIVE_AUTOMATION_LOG_LEVEL=DEBUG
claude code
```

#### Getting Help

- Ask Claude to list sessions if you lose track
- Use expect_and_respond with simple patterns to test connectivity
- Check MCP server status: `claude mcp list`

### Development Testing

```bash
# Run basic functionality tests
python tests/test_core.py
python tests/test_basic.py

# Install with development dependencies
pip install -e ".[dev]"

# Run code quality checks
ruff check src/ tests/
mypy src/ --ignore-missing-imports

# Run all tests
pytest tests/
```

## 💡 Universal Examples

### 🔑 Interactive Session Examples
```bash
# Natural language commands to Claude (keywords that trigger MCP tools):
"Create interactive session: SSH to prod.example.com and check disk usage"
"Execute command: mysql -u root -p and show tables"
"Create session: gdb myprogram and set breakpoints"
"Execute interactively: python -m pdb myscript.py"
"Run with automation: ssh user@host (handle password prompts)"
"Create interactive session: docker exec -it container bash"
"Execute command: kubectl exec -it pod sh and list files"
"Start session: redis-cli and check memory usage"
```

### 🚀 Truly Universal Examples
```bash
# ANY command that runs in a terminal:
"Run interactive session: ssh user@host"
"Execute interactively: docker exec -it myapp bash"
"Start session: kubectl exec -it pod-name -- sh"
"Launch: nc -l 8080"
"Run: socat - TCP:localhost:3000"
"Start interactive Python: python3 -c 'import code; code.interact()'"
"Launch my custom REPL: ./my-custom-repl --debug"
"Open serial connection: minicom /dev/ttyUSB0"
"Start screen session: screen /dev/ttyACM0 9600"
"Attach to tmux: tmux attach-session -t main"
```

### 🐍 Python Debugging Examples
```bash
# Natural language commands to Claude:
"Start a PDB debugging session with my Python script bug_script.py"
"Debug my Flask app: set breakpoints, inspect variables, and trace execution"
"Connect to a running Python process with PDB and debug live issues"
"Analyze a Python crash: load core dump, examine stack trace, identify root cause"
```

### 🔧 Advanced Automation
```bash
# Natural language commands to Claude:
"Connect to SSH, then connect to database, run diagnostics, and generate report"
"Debug the crashed server binary, analyze the core dump, and suggest fixes"
"Connect to multiple servers, check their status, and restart services if needed"
"Set up debugging session with custom debugger and analyze the issue"
```

## 🔒 Security

**Universal Design Philosophy**: Maximum flexibility with user responsibility
- **No command filtering** - All commands allowed (including `sudo`, `su`, system commands)
- **No path restrictions** - All paths accessible (user controls access)
- **Rate limiting** - 60 calls per minute to prevent abuse
- **Session limits** - 50 concurrent sessions to prevent resource exhaustion
- **Comprehensive logging** - Full audit trail of all operations
- **User responsibility** - Security is managed by the user, not the MCP server

## 📁 Project Structure

```
interactive-automation-mcp/
├── pyproject.toml              # Modern Python project configuration
├── README.md                   # This comprehensive guide
├── CLAUDE.md                   # Development and technical documentation
├── src/
│   └── interactive_automation_mcp/
│       ├── __init__.py        # Package initialization
│       ├── main.py            # Main MCP server entry point (FastMCP)
│       ├── session_manager.py # Session lifecycle management
│       ├── automation_engine.py # Enhanced automation engine
│       ├── interactive_session.py # Session handling with error recovery
│       ├── security.py        # Security controls and validation
│       ├── models.py          # Pydantic models for type safety
│       └── ...                # Other modules
├── tests/                      # Comprehensive test suite
├── docs/                       # Documentation
└── examples/                   # Example scripts for tutorials
    └── example_debug.py       # Tutorial debugging script
```

## 🚀 Development Status

- ✅ **Production Ready** - All 6 universal tools implemented and tested
- ✅ **FastMCP Architecture** - Modern MCP Python SDK 1.12.0 implementation
- ✅ **Enhanced Automation** - Smart pattern matching, error recovery, timeout handling
- ✅ **Type Safety** - Full Pydantic model validation and mypy type coverage
- ✅ **Minimal Dependencies** - Only 4 essential dependencies (reduced from 9)
- ✅ **Complete Security** - Comprehensive security controls with user responsibility
- ✅ **Clean Architecture** - Well-organized, maintainable code with modern tooling
- ✅ **Python Debugging** - Full PDB integration with comprehensive tutorial
- ✅ **Code Quality** - All linting (ruff) and type checking (mypy) passes

## 📄 License

MIT License - see LICENSE file for details

## 🤝 Contributing

1. Fork the repository
2. Create a feature branch (`git checkout -b feature/amazing-feature`)
3. Make your changes
4. Add tests for new functionality
5. Ensure all tests pass: `ruff check src/ tests/ && mypy src/ --ignore-missing-imports`
6. Commit your changes (`git commit -m 'Add amazing feature'`)
7. Push to the branch (`git push origin feature/amazing-feature`)
8. Open a Pull Request

## 🙏 Acknowledgments

- Built on the [Model Context Protocol (MCP)](https://github.com/anthropics/mcp) by Anthropic
- Uses [pexpect](https://pexpect.readthedocs.io/) for terminal automation
